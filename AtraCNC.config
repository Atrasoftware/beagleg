# -*- conf -*-
# Some annotated BeagleG sample configuration file.
# Adapt to your own needs.
# You can configure logical axes X, Y, Z, E, A, B, C, U, V, W
# Pass to machine-control with -c <config-file> option.
##

[ General ]
# Homing order. For 3D printers, you'd probably home Z last, while CNC machines
# typically home Z first.
home-order        = XYZA
require-homing    = yes  # Require homing (G28) is executed before first move.
range-check       = yes  # Check that axes are within range. Dangerous if no.
auto-motor-disable-seconds = 3  # Switch off motors after tot seconds of inactivity.

# -- Logical axis configuration

[ X-Axis ]
# The step motor has 200 full steps per turn. We do 32x microstepping
# One turn of a gear moves the toothed belt 60mm. The configuration understands
# a simple division expression:
steps-per-mm     = 1000 / 6
max-feedrate     = 200   # mm/s
max-acceleration = 600  # mm/s^2
range            = 465   # mm - the travel of this axis
home-pos         = min   # This is where the home switch is. At min position.

[ Y-Axis ]
steps-per-mm     = 1000 / 6
max-feedrate     = 200  # mm/s
max-acceleration = 600  # mm/s^2
range            = 500  # mm
home-pos         = min

[ Z-Axis ]
steps-per-mm     = 1000 / 6
max-feedrate     = 200  # mm/s
max-acceleration = 700  # mm/s^2
range            = 150  # mm
home-pos         = min

[ A-Axis ]
# Example component axis, unit is in cc 1 turn = 12cc with 32 usteps resolution
steps-per-mm     = 1000 * 4 / 5
max-feedrate     = 30 #cc/s
max-acceleration = 50 #cc/s^2
range            = 38
home-pos         = min

# Hardware mapping; which axes and switches are connected to which logical units.

[ Motor-Mapping ]
# If you don't happen to have a motor-mapping section, motors are assigned
# for the configured axis above in sequence XYZEABCUVW
motor_1 = axis:-x   # X axis connected to motor 1
motor_2 = axis:-y
motor_3 = axis:-z
motor_4 = axis:a

[ Switch-Mapping ]
# These switches trigger on high: when activated, they generate a pos level.
switch_1 = active:high min_x
switch_2 = active:high min_y
switch_3 = active:high min_z
switch_4 = active:low min_a

# You can have multiple switches wired together in case you only have a limited
# number of inputs or want to simplify wiring (put them electrically in series
# or parallel to get a logical 'or' to reach the switching level if either
# of these trigger). It is probably a good idea to have home-switches independent
# of each other, while lumping together all the limit switches (only used for
# exceptions anyway) can simplify wiring.
#switch_4 = active:low min_a

# An example of a switch that triggers on low.
#switch_5 = active:low max_z
